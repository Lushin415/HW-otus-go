// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO schema.Orders (id_user_f, order_date, total_amount)
VALUES ($1, $2, $3)
    RETURNING id_order_main
`

type CreateOrderParams struct {
	IDUserF     int32          `json:"idUserF"`
	OrderDate   pgtype.Date    `json:"orderDate"`
	TotalAmount pgtype.Numeric `json:"totalAmount"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (int32, error) {
	row := q.db.QueryRow(ctx, createOrder, arg.IDUserF, arg.OrderDate, arg.TotalAmount)
	var id_order_main int32
	err := row.Scan(&id_order_main)
	return id_order_main, err
}

const createOrderProduct = `-- name: CreateOrderProduct :exec
INSERT INTO schema.Order_Products (id_order_f, id_product_f, quantity)
VALUES ($1, $2, $3)
`

type CreateOrderProductParams struct {
	IDOrderF   int32 `json:"idOrderF"`
	IDProductF int32 `json:"idProductF"`
	Quantity   int32 `json:"quantity"`
}

func (q *Queries) CreateOrderProduct(ctx context.Context, arg CreateOrderProductParams) error {
	_, err := q.db.Exec(ctx, createOrderProduct, arg.IDOrderF, arg.IDProductF, arg.Quantity)
	return err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO schema.Products (name_product, price)
VALUES ($1, $2)
    RETURNING id_product_main
`

type CreateProductParams struct {
	NameProduct string         `json:"nameProduct"`
	Price       pgtype.Numeric `json:"price"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProduct, arg.NameProduct, arg.Price)
	var id_product_main int32
	err := row.Scan(&id_product_main)
	return id_product_main, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO schema.Users (name_user, email, password)
VALUES ($1, $2, $3)
    RETURNING id_user_main
`

type CreateUserParams struct {
	NameUser string `json:"nameUser"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser, arg.NameUser, arg.Email, arg.Password)
	var id_user_main int32
	err := row.Scan(&id_user_main)
	return id_user_main, err
}

const deleteCheapProducts = `-- name: DeleteCheapProducts :one
WITH deleted AS (
DELETE FROM schema.Products
WHERE price < $1
    RETURNING id_product_main, name_product, price
)
SELECT count(*) FROM deleted
`

func (q *Queries) DeleteCheapProducts(ctx context.Context, price pgtype.Numeric) (int64, error) {
	row := q.db.QueryRow(ctx, deleteCheapProducts, price)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM schema.Orders WHERE id_order_main = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, idOrderMain int32) error {
	_, err := q.db.Exec(ctx, deleteOrder, idOrderMain)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM schema.Users WHERE email = $1
`

func (q *Queries) DeleteUser(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUser, email)
	return err
}

const getOrderByUserID = `-- name: GetOrderByUserID :many
SELECT id_order_main, order_date, total_amount
FROM schema.Orders
WHERE id_user_f = $1
`

type GetOrderByUserIDRow struct {
	IDOrderMain int32          `json:"idOrderMain"`
	OrderDate   pgtype.Date    `json:"orderDate"`
	TotalAmount pgtype.Numeric `json:"totalAmount"`
}

func (q *Queries) GetOrderByUserID(ctx context.Context, idUserF int32) ([]GetOrderByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getOrderByUserID, idUserF)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderByUserIDRow{}
	for rows.Next() {
		var i GetOrderByUserIDRow
		if err := rows.Scan(&i.IDOrderMain, &i.OrderDate, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByPriceRange = `-- name: GetProductsByPriceRange :many
SELECT id_product_main, name_product, price FROM schema.Products WHERE price BETWEEN $1 AND $2
`

type GetProductsByPriceRangeParams struct {
	Price   pgtype.Numeric `json:"price"`
	Price_2 pgtype.Numeric `json:"price2"`
}

func (q *Queries) GetProductsByPriceRange(ctx context.Context, arg GetProductsByPriceRangeParams) ([]SchemaProduct, error) {
	rows, err := q.db.Query(ctx, getProductsByPriceRange, arg.Price, arg.Price_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchemaProduct{}
	for rows.Next() {
		var i SchemaProduct
		if err := rows.Scan(&i.IDProductMain, &i.NameProduct, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSpendingStats = `-- name: GetUserSpendingStats :many
SELECT
    u.name_user,
    COALESCE(SUM(op.quantity * p.price), 0) AS total_spent,
    COALESCE(SUM(p.price * op.quantity) / NULLIF(SUM(op.quantity), 0), 0) AS avg_product_price
FROM schema.Users u
         LEFT JOIN schema.Orders o ON u.id_user_main = o.id_user_f
         LEFT JOIN schema.Order_Products op ON o.id_order_main = op.id_order_f
         LEFT JOIN schema.Products p ON op.id_product_f = p.id_product_main
GROUP BY u.name_user
`

type GetUserSpendingStatsRow struct {
	NameUser        string      `json:"nameUser"`
	TotalSpent      interface{} `json:"totalSpent"`
	AvgProductPrice interface{} `json:"avgProductPrice"`
}

func (q *Queries) GetUserSpendingStats(ctx context.Context) ([]GetUserSpendingStatsRow, error) {
	rows, err := q.db.Query(ctx, getUserSpendingStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserSpendingStatsRow{}
	for rows.Next() {
		var i GetUserSpendingStatsRow
		if err := rows.Scan(&i.NameUser, &i.TotalSpent, &i.AvgProductPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByPassword = `-- name: GetUsersByPassword :many
SELECT id_user_main, name_user, email, password FROM schema.Users WHERE password = $1
`

func (q *Queries) GetUsersByPassword(ctx context.Context, password string) ([]SchemaUser, error) {
	rows, err := q.db.Query(ctx, getUsersByPassword, password)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchemaUser{}
	for rows.Next() {
		var i SchemaUser
		if err := rows.Scan(
			&i.IDUserMain,
			&i.NameUser,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderTotal = `-- name: UpdateOrderTotal :exec
UPDATE schema.Orders
SET total_amount = (
    SELECT COALESCE(SUM(op.quantity * p.price), 0)
    FROM schema.Order_Products op
             JOIN schema.Products p ON op.id_product_f = p.id_product_main
    WHERE op.id_order_f = schema.Orders.id_order_main
)
`

func (q *Queries) UpdateOrderTotal(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateOrderTotal)
	return err
}

const updateProductPrice = `-- name: UpdateProductPrice :exec
UPDATE schema.Products
SET price = $1
WHERE id_product_main = $2
`

type UpdateProductPriceParams struct {
	Price         pgtype.Numeric `json:"price"`
	IDProductMain int32          `json:"idProductMain"`
}

func (q *Queries) UpdateProductPrice(ctx context.Context, arg UpdateProductPriceParams) error {
	_, err := q.db.Exec(ctx, updateProductPrice, arg.Price, arg.IDProductMain)
	return err
}

const updateUserName = `-- name: UpdateUserName :exec
UPDATE schema.Users
SET name_user = $1
WHERE email = $2
`

type UpdateUserNameParams struct {
	NameUser string `json:"nameUser"`
	Email    string `json:"email"`
}

func (q *Queries) UpdateUserName(ctx context.Context, arg UpdateUserNameParams) error {
	_, err := q.db.Exec(ctx, updateUserName, arg.NameUser, arg.Email)
	return err
}
