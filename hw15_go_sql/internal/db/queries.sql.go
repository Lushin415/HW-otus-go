// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO schema.Users (name_user, email, password)
VALUES ($1, $2, $3)
    RETURNING id_user_main
`

type CreateUserParams struct {
	NameUser string `json:"name_user"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser, arg.NameUser, arg.Email, arg.Password)
	var id_user_main int32
	err := row.Scan(&id_user_main)
	return id_user_main, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM schema.Users WHERE id_user_main = $1
`

func (q *Queries) DeleteUser(ctx context.Context, idUserMain int32) error {
	_, err := q.db.Exec(ctx, deleteUser, idUserMain)
	return err
}

const getOrdersByUser = `-- name: GetOrdersByUser :many
SELECT id_order_main, order_date, total_amount
FROM schema.Orders
WHERE id_user_f = $1
`

type GetOrdersByUserRow struct {
	IDOrderMain int32          `json:"id_order_main"`
	OrderDate   pgtype.Date    `json:"order_date"`
	TotalAmount pgtype.Numeric `json:"total_amount"`
}

func (q *Queries) GetOrdersByUser(ctx context.Context, idUserF int32) ([]GetOrdersByUserRow, error) {
	rows, err := q.db.Query(ctx, getOrdersByUser, idUserF)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdersByUserRow{}
	for rows.Next() {
		var i GetOrdersByUserRow
		if err := rows.Scan(&i.IDOrderMain, &i.OrderDate, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByPriceRange = `-- name: GetProductsByPriceRange :many
SELECT id_product_main, name_product, price
FROM schema.Products
WHERE price BETWEEN $1 AND $2
`

type GetProductsByPriceRangeParams struct {
	Price   pgtype.Numeric `json:"price"`
	Price_2 pgtype.Numeric `json:"price_2"`
}

func (q *Queries) GetProductsByPriceRange(ctx context.Context, arg GetProductsByPriceRangeParams) ([]SchemaProduct, error) {
	rows, err := q.db.Query(ctx, getProductsByPriceRange, arg.Price, arg.Price_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SchemaProduct{}
	for rows.Next() {
		var i SchemaProduct
		if err := rows.Scan(&i.IDProductMain, &i.NameProduct, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id_user_main, name_user, email, password
FROM schema.Users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (SchemaUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i SchemaUser
	err := row.Scan(
		&i.IDUserMain,
		&i.NameUser,
		&i.Email,
		&i.Password,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id_user_main, name_user, email FROM schema.Users WHERE id_user_main = $1
`

type GetUserByIDRow struct {
	IDUserMain int32  `json:"id_user_main"`
	NameUser   string `json:"name_user"`
	Email      string `json:"email"`
}

func (q *Queries) GetUserByID(ctx context.Context, idUserMain int32) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, idUserMain)
	var i GetUserByIDRow
	err := row.Scan(&i.IDUserMain, &i.NameUser, &i.Email)
	return i, err
}

const getUserSpendingMetrics = `-- name: GetUserSpendingMetrics :many
SELECT
    u.id_user_main,
    u.name_user,
    COALESCE(SUM(op.quantity * p.price), 0) AS total_spent,
    COALESCE(SUM(p.price * op.quantity) / NULLIF(SUM(op.quantity), 0), 0) AS avg_product_price
FROM schema.Users u
         LEFT JOIN schema.Orders o ON u.id_user_main = o.id_user_f
         LEFT JOIN schema.Order_Products op ON o.id_order_main = op.id_order_f
         LEFT JOIN schema.Products p ON op.id_product_f = p.id_product_main
GROUP BY u.id_user_main, u.name_user
`

type GetUserSpendingMetricsRow struct {
	IDUserMain      int32       `json:"id_user_main"`
	NameUser        string      `json:"name_user"`
	TotalSpent      interface{} `json:"total_spent"`
	AvgProductPrice interface{} `json:"avg_product_price"`
}

func (q *Queries) GetUserSpendingMetrics(ctx context.Context) ([]GetUserSpendingMetricsRow, error) {
	rows, err := q.db.Query(ctx, getUserSpendingMetrics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserSpendingMetricsRow{}
	for rows.Next() {
		var i GetUserSpendingMetricsRow
		if err := rows.Scan(
			&i.IDUserMain,
			&i.NameUser,
			&i.TotalSpent,
			&i.AvgProductPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT id_user_main, name_user, email FROM schema.Users
`

type GetUsersRow struct {
	IDUserMain int32  `json:"id_user_main"`
	NameUser   string `json:"name_user"`
	Email      string `json:"email"`
}

func (q *Queries) GetUsers(ctx context.Context) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(&i.IDUserMain, &i.NameUser, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByPasswordPattern = `-- name: GetUsersByPasswordPattern :many
SELECT id_user_main, name_user, email
FROM schema.Users
WHERE password LIKE $1
`

type GetUsersByPasswordPatternRow struct {
	IDUserMain int32  `json:"id_user_main"`
	NameUser   string `json:"name_user"`
	Email      string `json:"email"`
}

func (q *Queries) GetUsersByPasswordPattern(ctx context.Context, password string) ([]GetUsersByPasswordPatternRow, error) {
	rows, err := q.db.Query(ctx, getUsersByPasswordPattern, password)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersByPasswordPatternRow{}
	for rows.Next() {
		var i GetUsersByPasswordPatternRow
		if err := rows.Scan(&i.IDUserMain, &i.NameUser, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProductPrice = `-- name: UpdateProductPrice :exec
UPDATE schema.Products
SET price = $1
WHERE id_product_main = $2
`

type UpdateProductPriceParams struct {
	Price         pgtype.Numeric `json:"price"`
	IDProductMain int32          `json:"id_product_main"`
}

func (q *Queries) UpdateProductPrice(ctx context.Context, arg UpdateProductPriceParams) error {
	_, err := q.db.Exec(ctx, updateProductPrice, arg.Price, arg.IDProductMain)
	return err
}
